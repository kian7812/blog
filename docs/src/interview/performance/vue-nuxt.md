# Vue3性能优化

## 分析选项​
https://cn.vuejs.org/guide/best-practices/performance.html#profiling-options

为了提高性能，我们首先需要知道如何衡量它。在这方面，有一些很棒的工具可以提供帮助：

用于生产部署的负载性能分析：
- CPageSpeed Insights
- CWebPageTest

用于本地开发期间的性能分析：
- Chrome 开发者工具“性能”面板
- *app.config.performance 将会开启 Vue 特有的性能标记，标记在 Chrome 开发者工具的性能时间线上*。
- *Vue 开发者扩展也提供了性能分析的功能*。

## 性能优化（官方文档）

https://cn.vuejs.org/guide/best-practices/performance.html

首先，让我们区分一下 web 应用性能的两个主要方面：页
- 面加载性能：首次访问时，应用展示出内容与达到可交互状态的速度。
- 更新性能：应用响应用户输入更新的速度。

**页面加载优化**

减小包体积

- Tree-shaking 优化：选择提供 ES 模块格式的包
- 代码分割：动态import、路由懒加载、异步组件
- gzip压缩

**更新优化**

减少响应式变量的影响范围，从而减少re-render.

- Props 稳定性：这个技巧的核心思想就是让传给子组件的 props 尽量保持稳定。
- v-once 它的整个子树都会在未来的更新中被跳过。
- v-memo 可以用来有条件地跳过某些大型子树或者 v-for 列表的更新。

**通用优化**

- 减少大型不可变数据的响应性开销
    - Vue 的响应性系统默认是深度的。在数据量巨大时，深度响应性也会导致不小的性能负担，因为每个属性访问都将触发代理的依赖追踪。好在这种性能负担通常只有在处理超大型数组或层级很深的对象时，例如一次渲染需要访问 100,000+ 个属性时，才会变得比较明显。
    - Vue 确实也为此提供了一种解决方案，通过使用 shallowRef() 和 shallowReactive() 来绕开深度响应。浅层式 API 创建的状态只在其顶层是响应式的，对所有深层的对象不会做任何处理。
- 避免不必要的组件抽象
    - 有些时候我们会去创建无渲染组件或高阶组件 (用来渲染具有额外 props 的其他组件) 来实现更好的抽象或代码组织。虽然这并没有什么问题，但请记住，组件实例比普通 DOM 节点要昂贵得多，而且为了逻辑抽象创建太多组件实例将会导致性能损失。（这句话意思：可以在于组件会进行响应式依赖吧）
    - 需要提醒的是，考虑这种优化的最佳场景还是在大型列表中。想象一下一个有 100 项的列表，每项的组件都包含许多子组件。在这里去掉一个不必要的组件抽象，可能会减少数百个组件实例的无谓性能消耗。

## Vue3 编译阶段优化

https://cn.vuejs.org/guide/extras/rendering-mechanism.html#compiler-informed-virtual-dom

在 React 中（大多数实现都是纯运行时的），更新算法无法预知新的虚拟 DOM 树会是怎样，因此它总是需要遍历整棵树、比较每个 vnode 上 props 的区别来确保正确性。另外，即使一棵树的某个部分从未改变，还是会在每次重渲染时创建新的 vnode，带来了大量不必要的内存压力。

在 Vue 中，框架同时控制着编译器和运行时。这使得我们可以为紧密耦合的模板渲染器应用许多编译时优化。编译器可以静态分析模板并在生成的代码中留下标记，使得运行时尽可能地走捷径。

Vue 编译器用来提高虚拟 DOM 运行时性能的主要优化：
1. 静态提升
    - foo 和 bar 这两个 div 是完全静态的，没有必要在重新渲染时再次创建和比对它们。Vue 编译器自动地会提升这部分 vnode 创建函数到这个模板的渲染函数之外，并在每次渲染时都使用这份相同的 vnode，渲染器知道新旧 vnode 在这部分是完全相同的，所以会完全跳过对它们的差异比对。
    - 更多内容看文章

2. 更新类型标记（名词）
  - 运行时渲染器也将会使用位运算来检查这些标记，确定相应的更新操作。位运算检查是非常快的。通过这样的更新类型标记，Vue 能够在更新带有动态绑定的元素时做最少的操作。

3. 树结构打平（不明觉厉）
    - 每一个块都会追踪其所有带更新类型标记的后代节点

举例来说：
```html
<div> <!-- root block -->
  <div>...</div>         <!-- 不会追踪 -->
  <div :id="id"></div>   <!-- 要追踪 -->
  <div>                  <!-- 不会追踪 -->
    <div>{{ bar }}</div> <!-- 要追踪 -->
  </div>
</div>
```
编译的结果会被打平为一个数组，仅包含所有动态的后代节点：
```
div (block root)
- div 带有 :id 绑定
- div 带有 {{ bar }} 绑定
```

当这个组件需要重渲染时，只需要遍历这个打平的树而非整棵树。这也就是我们所说的树结构打平，这大大减少了我们在虚拟 DOM 协调时需要遍历的节点数量。模板中任何的静态部分都会被高效地略过。

4. 对 SSR 激活的影响

**更新类型标记和树结构**打平都大大提升了 Vue SSR 激活的性能表现。


## 谈谈Vue的性能优化有哪些？
* 数据层级不要过深，合理的设置响应式数据
* 使用数据时，缓存值的结果，不频繁取值
* 合理设置key
* v-show(频繁切换性能高)和v-if的合理使用
* 控制组件的粒度 -> Vue采用组件级别更新
* 采用函数式组件 -> 函数式组价开销低
* 采用异步组件 -> 借助webpack的分包策略
* 使用keep-alive来缓存组件
* 虚拟滚动、时间分片等策略
* 打包优化


## 你都做过哪些Vue的性能优化？
编码阶段
* 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher
* v-if和v-for不能连⽤
* 如果需要使⽤v-for给每项元素绑定事件时使⽤事件代理
* SPA ⻚⾯采⽤keep-alive缓存组件
* 在更多的情况下，使⽤v-if替代v-show
* key保证唯⼀
* 使⽤路由懒加载、异步组件
* 防抖、节流
* 第三⽅模块按需导⼊
* ⻓列表滚动到可视区域动态加载
* 图⽚懒加载
SEO优化
* 预渲染
* 服务端渲染SSR
打包优化
* 压缩代码
* Tree Shaking/Scope Hoisting
* 使⽤cdn加载第三⽅模块
* 多线程打包happypack
* splitChunks抽离公共⽂件
* sourceMap优化
⽤户体验
* 骨架屏
* PWA

## 你都做过哪些 Vue 的性能优化

这里只列举针对 Vue 的性能优化 整个项目的性能优化是一个大工程 可以另写一篇性能优化的文章 哈哈


对象层级不要过深，否则性能就会差
不需要响应式的数据不要放到 data 中（可以用 Object.freeze() 冻结数据）
v-if 和 v-show 区分使用场景
computed 和 watch 区分使用场景
v-for 遍历必须加 key，key 最好是 id 值，且避免同时使用 v-if
大数据列表和表格性能优化-虚拟列表/虚拟表格
防止内部泄漏，组件销毁后把全局变量和事件销毁
图片懒加载
路由懒加载
第三方插件的按需引入
适当采用 keep-alive 缓存组件
防抖、节流运用
服务端渲染 SSR or 预渲染

作者：前端鲨鱼哥
链接：https://juejin.cn/post/6961222829979697165
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。