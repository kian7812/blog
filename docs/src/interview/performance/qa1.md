```
如何回答性能优化的问题：
单页面首屏优化，打包后大小减少64M，加载速度快了13.6秒（做了哪些事情，效果如何，如何做的）
https://juejin.cn/post/7359077652445806642
https://mp.weixin.qq.com/s/hzhXQaEQ8TmAgnNwqJ1lMw


---5.4
- 优化
项目搭建时优化：
- 减小包的体积：
    路由懒加载/代码分割/nuxt默认支持，小的chunk
    按需引入ui库、echarts等，组件懒加载、按需引入。
    支持treeshaking js包如lodash-es、vue3api本身这块支持
    动态引入语言包
    splitChunks 分包，可把常用库打到一起。最小chunk数量。
- gzip压缩支持、cdn可把常用库放到上面。域名相同加快解析速度。
- 打包分析工具 analyze ，因为现在线上都支持http2，支持多路复用，没有请求限制，包粒度小些更好，可同时加载。


- 开发时
    图片处理，如果再首屏直接加载、非首屏可考虑异步展示，可使用nuxt-image组件服务，可配置图片格式等webp，还可以配置服务，功能比较多。
    注意，特别是创建特别大的响应式数据时，可考虑使用shallow ref reactive，只做外层响应式，不深度遍历依赖。减少运行时内存消耗。
- 运行时优化排查：
    lighthose-PageSpeed：
        首次内容绘制（First Contentful Paint）。即浏览器首次将任意内容（如文字、图像、canvas 等）绘制到屏幕上的时间点。（主要考察首屏是第一个元素开始渲染时间，考察首屏必要资源加载时间）、lcp最大绘制完成时间（首屏绘制完成时间，考察图片是否加载慢、首屏dom是否复杂导致绘制慢等等）
    还有seo相关的，平时开发时，注意添加到页面
- 还有跑下performance，首屏看下加载和渲染过程，关注下长任务；还有如果有操作有卡顿也可以通过这个方式排查。切分任务。
- 还有seo相关的，


- 首屏优化


图片格式 png 、jpg / jpeg、svg、webp
图片大小 优先保证UI精度，必须经过 UI 验收，高倍图<400kb、低倍图<200kb、手机端<100kb
懒加载
容器 父元素不可隐藏，并显示设置 width、height
图片 显示设置 width、height
懒加载容器使用局部 loading 可选
接口 SSR 规范 使用时必须是后端提供的 接口
首屏渲染（第一屏） 不使用 loading、骨架屏等懒加载方式


- 然后**简述下http2.0与http1.1的显著不同点**：




- http1.1中，每请求一个资源，都是需要开启一个tcp/ip连接的，所以对应的结果是，每一个资源对应一个tcp/ip请求，由于tcp/ip本身有并发数限制，所以当资源一多，速度就显著慢下来
浏览器为每个域名最多同时维护 6 个 TCP 持久连接；


- http2.0中，一个tcp/ip请求可以请求多个资源，也就是说，只要一次tcp/ip请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。


所以，如果http2.0全面应用，很多http1.1中的优化方案就无需用到了（*譬如打包成精灵图，静态资源多域名拆分等*）




然后简述下**http2.0的一些特性**：

- 多路复用（即一个tcp/ip连接可以请求多个资源）
- 首部压缩（http头部压缩，减少体积）


- 二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）


- 服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）


- 请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）


```
