# JavaScript 手写题

## call

语法：fn.call(obj,...args)

功能：执行 fn，使 this 为 obj，并将后面的 n 个参数传给 fn

```js
Function.prototype.myCall = function (obj, ...args) {
  if (obj == undefined || obj == null) {
    // ES2020 在语言标准的层面，引入globalThis作为顶层对象
    obj = globalThis; 
  }
  // 通过函数调用myCall，那myCall里的this就是函数本身
  obj.fn = this;
  // fn函数里通过obj调佣的，那fn函数里的this指向obj
  let res = obj.fn(...args);
  delete obj.fn;
  return res;
};

value = 2;

let foo = {
  value: 1,
};

let bar = function (name, age) {
  console.log(name, age, this.value);
};

bar.myCall(foo, "HearLing", 18); // HearLing 18 1
bar.myCall(null, "HearLing", 18); // HearLing 18 2
```

步骤解释：https://github.com/mqyqingfeng/Blog/issues/11

## apply

语法：fn.apply(obj,arr)

功能：执行 fn，使 this 为 obj，并 arr 数组中元素传给 fn

```js
Function.prototype.myAplly = function (obj, arr) {
  if (obj == undefined || obj == null) {
    obj = globalThis;
  }
  obj.fn = this;
  let res = obj.fn(...arr);
  delete obj.fn;
  return res;
};
value = 2;

let foo = {
  value: 1,
};

let bar = function (name, age) {
  console.log(name, age, this.value);
};

bar.myAplly(foo, ["HearLing", 18]); // HearLing 18 1
bar.myAplly(null, ["HearLing", 18]); // HearLing 18 2
```

## bind

语法：fn.bind(obj,...args)

功能：返回一个新函数，给 fn 绑定 this 为 obj，并制定参数为后面的 n 个参数

```js
Function.prototype.myBind = function (obj, ...args) {
  // 通过函数调用myBind，那myBind里的this就是函数本身
  let that = this;
  let fn = function () {
    // 这里this指向调用fn的地方
    if (this instanceof fn) {
      return new that(...args);
    } else {
      return that.call(obj, ...args);
    }
  };
  return fn;
};

value = 2;

let foo = {
  value: 1,
};

let bar = function (name, age) {
  console.log(name, age, this.value);
};
let fn = bar.myBind(foo, "HearLing", 18);
//fn() //HearLing 18 1
let a = new fn(); //HearLing 18 undefined
console.log(a.__proto__); //bar {}
```

## call、apply、bind 区别

call(obj)、apply(obj)：直接调用函数, 指定函数中的 this 为第一个参数的值

bind(obj)：返回一个新的函数, 新函数内部会调用原来的函数, 且 this 为 bind()指定的第一参数的值

## 节流 throttle

- 理解：在函数多次频繁触发时，函数执行一次后，只有大于设定的执行周期后才会执行第二次
- 场景：页面滚动（scroll）、DOM 元素的拖拽（mousemove）、抢购点击（click）、播放事件算进度信息
- 功能：节流函数在设置的 delay 毫秒内最多执行一次（简单点说就是，我上个锁，不管你点了多少下，时间到了我才解锁）

```js
function throttle(fn, delay = 200) {
  let flag = true;
  return (...args) => {
    if (!flag) return;
    flag = false;
    // args = arguments
    setTimeout(() => {
      fn.apply(this, args); // 改变this指向为调用debounce所指的对象
      flag = true;
    }, delay);
  };
}
```

## 防抖 debounce

- 理解：在函数频繁触发是，在规定之间以内，只让最后一次生效
- 场景：搜索框实时联想（keyup/input）、按钮点击太快，多次请求（登录、发短信）、窗口调整（resize）
- 功能：防抖函数在被调用后，延迟 delay 毫秒后调用，没到 delay 时间，你又点了，清空计时器重新计时，直到真的等了 delay 这么多秒。

```js
function debounce(fn, delay = 500) {
  let timer = null;
  return (...args) => {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      fn.apply(this, args); // 改变this指向为调用debounce所指的对象
    }, delay);
  };
}
```

## 节流与防抖的区别

首先概念上的不同，解释一下什么是防抖节流；然后就是使用场景的不同；

## 函数柯里化 curry

```js
function myCurry(fn, beforeRoundArg = []) {
  return function () {
    // args是累计参数
    let args = [...beforeRoundArg, ...arguments]; // arguments 是当前myCurry的参数
    // fn.length是函数fn的arguments个数，看下sum函数的
    // 当累计的参数args个数与fn函数参数个数相同时，开始调用fn
    if (args.length < fn.length) {
      return myCurry.call(this, fn, args); // 递归
    } else {
      return fn.apply(this, args);
    }
  };
}

function sum(a, b, c) {
  return a + b + c;
}

let sumFn = myCurry(sum);
console.log(sumFn(1)(2)(3)); // 6
```

## new

```js
function myNew(Fn, ...args) {
  const obj = {}
  obj.__proto__ = Fn.prototype
  Fn.apply(obj, args)
  return obj
}
```
加个条件：
```js
function newInstance(Fn, ...args) {
  const obj = {};
  obj.__proto__ = Fn.prototype;
  const result = Fn.apply(obj, args);
  // 如果Fn返回的是一个对象类型, 那返回该对象result，否则返回obj
  return result instanceof Object ? result : obj;
}
```

## instanceof

```js
function instance_of(left, right) {
  let prototype = right.prototype;
  while (true) {
    if (left === null) {
      return false;
    } else if (left.__proto__ === prototype) {
      return true;
    }
    left = left.__proto__;
  }
}
let a = {};
console.log(instance_of(a, Object)); // true
```

## 深拷贝 deepClone

```js
function deepClone (target, cache = new WeakMap()) {
  const isObject = (obj) => typeof obj === 'object' && obj !== null

  if (isObject(target)) {
    // cache 用来解决循环引用
    const cacheTarget = cache.get(target)
    
    if (cacheTarget) {
      return cacheTarget
    }

    let cloneTarget = Array.isArray(target) ? [] : {}

    cache.set(target, cloneTarget)

    for (const key in target) {
      // Object.hasOwnProperty.call(object, key)
      if (Object.hasOwn(target, key)) {
        const value = target[key] 
        cloneTarget[key] = isObject(value) ? deepClone(value, cache) : value
      }
    }

    return cloneTarget
  } else {
    return target
  }
}
```

数组浅拷贝

Array.prototype.slice()

## 数组扁平化 flat

```js
// 递归展开
function flattern1(arr) {
  let res = [];
  arr.foreach((item) => {
    if (Array.isArray(item)) {
      res.push(...flattern1(item));
    } else {
      res.push(item);
    }
  });
  return res;
}
```

## 数组去重 unique

```js
function unique(arr) {
  const res = [];
  const obj = {};
  arr.forEach((item) => {
    if (obj[item] === undefined) {
      obj[item] = true;
      res.push(item);
    }
  });
  return res;
}

// 其他方法
// Array.from(new Set(array))
// [...new Set(array)]
```

## 手写 reduce

```js
// 语法 array.reduce(function(prev, currentValue, currentIndex, arr), initialValue)
Array.prototype.MyReduce = function (fn, initialValue) {
  // 浅拷贝数组
  const arr = Array.prototype.slice.call(this);
  // 注意: reduce() 对于空数组是不会执行回调函数的。
  if (!arr.length) return;

  let res; // res(是上面的prev)
  // 默认初始值
  res = initialValue || arr[0];
  const start = initialValue ? 0 : 1 // 优化减少一次遍历
  // 遍历数组的每一个值
  for (let i = start; i < arr.length; i++) {
    // 每一个值都会在该方法中被（加工处理），
    res = fn.call(null, res, arr[i], i, this);
  }
  // 最后的返回值
  return res;
};
```

## 带并发的异步调度器 Scheduler

这类题目有很多，核心考察就是 限制运行任务的数量。

为了能快速理解，我先讲一个通俗的例子：首先要限制数量，我们可以用一个栈，栈不能超过两格（假设限制数量为2），当放进去的两个任务，一个快一些先执行完，那么弹出该任务，接下一个，如此类推。。。

进阶：两个请求一直占着位置，没有请求回数据，因为它们没执行完成导致后面的请求也进不来，导致阻塞，怎么办呢。。。第一肯定是要判断阻塞，两个请求占的时间过久。第二记录这两个请求并清空栈，允许其他链接请求。最后根据场景，对数据进行处理，比如你需要对没请求的数据再重新请求，或者提示等。

为了展示更加直观，我选了最经典的一道面试题：

**setTimeout 实现**

用 setTimeout 实现需要 注意 的是它是直接 add 的 time 和 val ，而不是返回 promise 的函数，所以可以在 add 里实现：

```js
// 设计并发调度器， 最多允许两个任务运行
const scheduler = new Scheduler(2);
// 这里的timer有的会写1有的会直接写1000，需要灵活解题
scheduler.addTask(5, "1");
scheduler.addTask(3, "2");
scheduler.addTask(1, "3");
scheduler.addTask(2, "4");
scheduler.start();
// 输出:2314
```

思路：

1. 用一个 count 记录并发的数量，用一个 taskList 数组保存任务。
2. addTask 如名字，将任务一一存入 taskList 。
3. 递归调用 start ，递归结束条件没有数据了，进入条件没有超过并发数。再通过 count 记录并发数量，从数组取出来一个 count++ ，执行完一个 count-- 。

```js
class Scheduler {
  constructor(maxNum) {
    this.maxNum = maxNum;
    this.count = 0;
    this.taskList = [];
  }

  addTask(time, val) {
    this.taskList.push([time, val]);
  }

  start() {
    if (!this.taskList.length) return;
    if (this.count < this.maxNum) {
      const [time, val] = this.taskList.shift();
      this.count++;
      setTimeout(() => {
        console.log(val);
        this.count--;
        this.start();
      }, time * 1000);
      this.start();
    }
  }
}
```

**promise 实现**

用 promise 写的话，实例代码就应该是下面这样：

```js
const timeout = (time) =>
  new Promise((resolve) => {
    setTimeout(resolve, time);
  });

const scheduler = new Scheduler();

const addTask = (time, order) => {
  scheduler.add(() => timeout(time).then(() => console.log(order)));
};

addTask(5000, "1");
addTask(3000, "2");
addTask(1000, "3");
addTask(2000, "4");
```

需要注意的是使用 promise 实现的话也是离不开循环 .then 的，所以我们抽出一个函数来实现 then 的链式调用。

1. 需要一个函数来实现 add 记录要执行的 promiseCreator ，还需要一个函数在执行的时候就去第一个就可以了。
2. 要求只有一个 add 函数，所以我们需要在 add 里记录 promiseCreator 以及执行 run 。
3. run 来触发异步函数的执行，这里的触发有两处，一处为 add 一个 promise 就 run ，另一个是自己执行完一个再 then 里执行 run ，当大于 max 时阻止继续 run 。

```js
class Scheduler {
  constructor() {
    this.taskList = [];
    this.maxNum = 2;
    this.count = 0;
  }

  add(promiseCreator) {
    this.taskList.push(promiseCreator);
    this.run();
  }

  run() {
    if (this.count >= this.maxNum || this.taskList.length == 0) return;

    this.count++;
    this.taskList
      .shift()()
      .then(() => {
        this.count--;
        this.run();
      });
  }
}
```

**async 实现**

最简单地写法还得是 async （这里换了一种写法，你也可以用类实现），然后帮助理解如果没有 start 函数，怎么直接在 add 函数中实现逻辑：

1. 用一个 count 记录并发的数量，用一个 taskList 数组保存任务。
2. 异步函数 add 接受异步任务返回 promise 。
3. 这里没有递归调用， add 一个异步任务，就执行，并用 count 记录并发数量。
4. 关键思想：当并发数超过限制，我们 await 一个不被 resolve 的 promise ，当完成了一个请求有位置了，才 resolve。

```js
function scheduler(maxNum) {
  const taskList = [];
  let count = 0;

  return async function add(promiseCreator) {
    if (count >= maxNum) {
      await new Promise((resolve, reject) => {
        taskList.push(resolve);
      });
    }
    count++;
    const res = await promiseCreator();
    count--;
    if (taskList.length > 0) taskList.shift()();

    return res;
  };
}
```

## 订阅发布 EventEmitter

实现一个发布订阅模式拥有on emit off once 方法

```js
class EventEmitter {
  constructor() {
    this.cache = {}
  }

  on(name, fn) {
    const tasks = this.cache[name]
    if (tasks) {
        this.cache[name].push(fn)
    } else {
        this.cache[name] = [fn]
    }
  }

  emit(name, ...args) {
    const tasks = this.cache[name].slice() // 复制一份，防止回调里继续on，导致死循环
    if (tasks) {
      for (let fn of tasks) {
        fn(...args)
      }
    }
  }


  off(name, fn) {
    const tasks = this.cache[name]
    if (task) {
      const index = tasks.findIndex(item => item === fn)
      if (index >= 0) {
        this.cache[name].splice(index, 1)
      }
    }
  }


  once(name, cb) {
    function fn(...args) {
      cb(args)
      this.off(name, fn)
    }
    this.on(name, fn)
  }
}
```

## 参考

- chodocs https://chodocs.cn/interview/js/
- fe-handwriting https://github.com/qianlongo/fe-handwriting/tree/master
- mqyqingfeng https://github.com/mqyqingfeng/Blog
- Sunshine_Lin https://juejin.cn/post/7035905352746926116